ğŸ‘‰ ReentrantLock
which is built on AbstractQueuedSynchronizer, AQS is a framework that manages a state variable
 and a FIFO queue of waiting threads to build synchronization tools like locks, semaphores, etc.
 AQS (Abstract Queued Synchronizer) is a low-level framework in Java used to build locks and synchronizers.

ğŸ§  PART 1: How AQS state Changes Step-by-Step
AQS has a very important variable: private volatile int state;

ğŸ”¹ What is state?
For ReentrantLock:
state = 0 â†’ unlocked
state = 1 â†’ locked once
state = N â†’ reentered N times

It represents the hold count.

ğŸ” Step-by-Step: lock() with No Contention
Step 1: Thread calls lock()
Internally: compareAndSetState(0, 1)
This is CAS (atomic CPU instruction).

Step 2: CAS succeeds, state = 1
owner thread = current thread
Lock acquired
âœ… No queue involved.

ğŸ” Reentrant Case (Same Thread Calls lock Again)
Thread already owns lock:
state = 1

Calls lock again â†’
AQS detects: Current thread == owner
So: state = state + 1
Now: state = 2
No blocking.

ğŸ”’ Step-by-Step: lock() With Contention

Suppose: Thread T1 holds lock (state = 1)
Thread T2 calls lock()

Step 1: CAS fails
Because state != 0.
Step 2: Thread T2 enters queue (via acquire())
AQS calls: addWaiter()
Now T2 becomes a Node in the queue.

Step 3: Thread T2 parks , LockSupport.park()
Thread goes to WAITING state.
ğŸ”“ Now Unlock Happens
Thread T1 calls unlock()
Internally: state = state - 1
If:state == 0
Then:owner = null
AQS wakes up next thread
unpark(nextThread)
Now T2 retries CAS.
If CAS succeeds:
state = 1
owner = T2

ğŸ§  Summary of State Transitions
Initial: state = 0

T1 lock() â†’ state = 1
T1 lock() â†’ state = 2
T1 unlock() â†’ state = 1
T1 unlock() â†’ state = 0
T2 lock() â†’ state = 1
State is just a counter â€” but controlled via CAS + ownership rules.
*************************************************************************************************
short note:
ğŸ‘‰ ReentrantLock is built on
ğŸ‘‰ AbstractQueuedSynchronizer (AQS),
which maintains a volatile int state representing the lock hold count.
Lock acquisition uses CAS (Compare And Swap), an atomic CPU operation that updates a value only if it matches the expected value.

If CAS succeeds â†’ lock is acquired immediately (no queueing).
If CAS fails â†’ the thread is placed in a CLH queue and parked.
Reentrancy is handled by incrementing state if the same thread acquires the lock again.
Unlock decrements state, and when it becomes 0, the next waiting thread is unparked.

============================================================================================
Disadvantages of synchronized
1ï¸... No Try-Lock Mechanism
With synchronized, a thread:
Either acquires the lock
Or blocks indefinitely
There is no way to try and fail immediately.
But ReentrantLock provides: tryLock() & tryLock(timeout) This helps avoid deadlocks and improve responsiveness.
*******
2ï¸... No Interruptible Lock Waiting

If a thread is waiting inside synchronized,
it cannot be interrupted.
It will wait forever until lock is released.

ReentrantLock provides: lockInterruptibly() So the thread can stop waiting if interrupted.
********
3ï¸.... No Fairness Option

synchronized:
Has no fairness policy
JVM decides which thread gets lock
Can cause thread starvation
ReentrantLock allows: new ReentrantLock(true) // fair lock
**********
4ï¸....No Multiple Condition Variables

With synchronized, you only have: wait() notify() notifyAll() Only one wait-set per object.
But ReentrantLock allows multiple Condition objects: lock.newCondition()
So you can have multiple independent waiting queues.
**************
5ï¸... No Explicit Unlocking Control

synchronized:
Lock is automatically released when block exits
No manual control
ReentrantLock:
Explicit lock() and unlock()
More flexible but must be used carefully

***********
6ï¸....Less Flexible for Advanced Concurrency

synchronized is:
Simpler
Less configurable
Modern concurrency utilities (like those built on
AbstractQueuedSynchronizer) offer:
Shared mode
Timed lock
Fair lock
Interruptible lock
Custom synchronizers